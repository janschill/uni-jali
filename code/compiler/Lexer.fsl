{
  // Helper functions

module Lexer

open FSharp.Text.Lexing
open Parser;

let lexemeAsString lexbuf =
  LexBuffer<char>.LexemeString lexbuf

let keyword s =
    match s with
    | "else"    -> ELSE
    | "false"   -> CONSTBOOL false
    | "if"      -> IF
    | "elseif"  -> ELSEIF
    | "true"    -> CONSTBOOL true
    | "func"    -> FUNCTION
    | _         -> NAME s

let previousIndentation = 0
let history = []

let readIndentation (currentIndentation) =
  printf "Previous indentation: %d \n" previousIndentation
  printf "Current indentation: %d \n" currentIndentation
  if currentIndentation = previousIndentation then
    // here we just wanna say 'Token lexbuf' in the Token rule :( ....
    INDENT
  else if currentIndentation = previousIndentation + 1 then
    INDENT
  else if currentIndentation = previousIndentation - 1 then
    DEDENT
  else 
    failwith "Lexer error: illegal indentation"

let readTabs (s : string) =
  readIndentation (s.Length)

let readSpaces (s : string) =
  readIndentation (s.Length / 2)



let show s = printf "%s. \n" s
// let show i = printf "%d" i


}


rule Token = parse
  | ['\t']*         { printf "tabs"; show (lexemeAsString lexbuf); readTabs (lexemeAsString lexbuf) } 
  | [' ']*          { printf "spaces"; show (lexemeAsString lexbuf); readSpaces (lexemeAsString lexbuf) }
  | [' ' '\r']      { show (lexemeAsString lexbuf); Token lexbuf; }
  | '\n'            { show (lexemeAsString lexbuf); lexbuf.EndPos <- lexbuf.EndPos.NextLine; NEWLINE }
  | ['0'-'9']+      { show (lexemeAsString lexbuf); CONSTINT (System.Int32.Parse (lexemeAsString lexbuf)) }
  | ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9']*  { show (lexemeAsString lexbuf); keyword (lexemeAsString lexbuf) }
  | '+'             { show (lexemeAsString lexbuf); PLUS }
  | '-'             { show (lexemeAsString lexbuf); MINUS }
  | '*'             { show (lexemeAsString lexbuf); TIMES }
  | '/'             { show (lexemeAsString lexbuf); DIV }
  | '%'             { show (lexemeAsString lexbuf); MOD }
  | '='             { show (lexemeAsString lexbuf); ASSIGN }
  | "=="            { show (lexemeAsString lexbuf); EQL }
  | '!'             { show (lexemeAsString lexbuf); NOT }
  | eof             { show (lexemeAsString lexbuf); EOF }
  | '('             { show (lexemeAsString lexbuf); LPAR }
  | ')'             { show (lexemeAsString lexbuf); RPAR }
