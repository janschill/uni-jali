%{
  open AbstractSyntax;
%}

%token <bool> CONSTBOOL
%token <int> CONSTINT
%token <string> NAME
%token ASSIGN
%token BOOLEAN
%token CHAR
%token COMMA
%token DIV
%token ELSE
%token ELSEIF
%token END
%token EOF
%token EQL
%token FLOAT
%token FUNCTION
%token GE
%token GT
%token IF
%token INT
%token LE
%token LPAR
%token LT
%token MINUS
%token MOD
%token NEWLINE
%token NOT
%token NOTEQL
%token PIPE
%token PLUS
%token RPAR
%token STRING
%token TIMES
%token TYPE

/* lowest precedence  */
%left ELSE
%left PLUS MINUS
%left TIMES DIV MOD
/* highest precedence  */
%nonassoc NOT

%start Main
%type <AbstractSyntax.expr> Main Value Expr Exp ADT Assignment FuncDef
%type <AbstractSyntax.types> TypeSpec
%%

Main:
    Program EOF { $1 }
;

Program: DeclarationList  { Program( $1 ) }

Declaration:
  | Expr                { $1 }
  | Assignment          { $1 }
  | FuncDef             { $1 }
  | ADT                 { $1 }
  | NEWLINE Declaration { $2 }    // handles empty lines

// Stmt: 
// | NAME ASSIGN Expr NEWLINE { Let($1, $3) }
// | BEGIN StmtList END { Seq(List.rev($2)) }    I want this one :'(

DeclarationList:
  | Declaration                          { [$1] }
  | Declaration NEWLINE                  { [$1] }   // handles newlines at end of file
  | Declaration NEWLINE DeclarationList  { $1 :: $3 }

Value:
    CONSTINT                    { ConstantInteger $1 }
  | CONSTBOOL                   { ConstantBoolean $1 }
  | NAME                        { Variable $1 }
  | LPAR Value COMMA Value RPAR { Tuple($2, $4) }

Exp:
  | Value           { $1                 }
  | MINUS Exp       { Prim("-", ConstantInteger 0, $2)  }
  | Exp PLUS  Exp   { Prim("+", $1, $3)  }
  | Exp MINUS Exp   { Prim("-", $1, $3)  }
  | Exp TIMES Exp   { Prim("*", $1, $3)  }
  | Exp DIV   Exp   { Prim("/", $1, $3)  }
  | Exp MOD   Exp   { Prim("%", $1, $3)  }
  | LPAR Expr RPAR  { $2 }

Expr:
  | Exp NOTEQL Exp  { Prim("!=", $1, $3) }
  | Exp EQL    Exp  { Prim("==", $1, $3) }
  | Exp GT     Exp  { Prim(">",  $1, $3) }
  | Exp LT     Exp  { Prim("<",  $1, $3) }
  | Exp GE     Exp  { Prim(">=", $1, $3) }
  | Exp LE     Exp  { Prim("<=", $1, $3) }
  | Exp             { $1 }

Assignment: NAME ASSIGN Expr                       { Let($1, $3) }

ExprList:
  | Expr NEWLINE                    { [$1] }
  | Assignment NEWLINE ExprList END { $1 :: $3 }
  | FuncDef ExprList END            { $1 :: $2 }

FuncDef:
  | FUNCTION NAME NAME ASSIGN Expr                    { Function($2, $3, [$5] ) }
  | FUNCTION NAME NAME ASSIGN NEWLINE ExprList        { Function($2, $3, $6 ) }

// ====== ADT grammar rules: =======
ADT:
  TYPE NAME ASSIGN ADTContructor { ADT($2, $4) }

ADTContructor:
    ADTSimpleConstructor   { $1 }
  | ADTCompoundConstructor { $1 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter                    { [adtconstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { adtconstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

// ADTSimpleConstructor:
//     NAME ADTConstructorParameter                    { [adtconstructor($1, $2)] }
//   | NAME ADTConstructorParameter PIPE ADTSimpleConstructor { adtconstructor($1, $2)::$4 }
//   | NAME ADTConstructorParameter NEWLINE PIPE ADTSimpleConstructor { adtconstructor($1, $2)::$5 }

// ADTCompoundConstructor:
//     NEWLINE ADTSimpleConstructor { $2 }
//   | PIPE ADTSimpleConstructor { $2 }
//   | NEWLINE PIPE ADTSimpleConstructor { $3 }

ADTConstructorParameter:
  | /* empty */                      { [] }
  | TypeSpec ADTConstructorParameter { $1::$2 }

TypeSpec:
    INT     { Int }
  | FLOAT   { Float }
  | BOOLEAN { Boolean }
  | STRING  { String }
  | CHAR    { Char }
  | NAME    { Typevar $1 }
