%{
  open AbstractSyntax;
%}

%token <bool> CONSTBOOL
%token <int> CONSTINT
%token <string> NAME
%token ASSIGN
%token BOOLEAN
%token CHAR
%token COMMA
%token DIV
%token ELSE
%token ELSEIF
%token END
%token EOF
%token EQL
%token FLOAT
%token FUNCTION
%token GE
%token GT
%token IF
%token INT
%token LE
%token LPAR
%token LT
%token MINUS
%token MOD
%token NEWLINE
%token NOT
%token NOTEQL
%token PIPE
%token PLUS
%token RPAR
%token STRING
%token TIMES
%token TYPE

/* lowest precedence  */
%left ELSE
%left PLUS MINUS
%left TIMES DIV MOD
/* highest precedence  */
%nonassoc NOT

%start Main
%type <AbstractSyntax.expr> Main Program Value Expr ADT Assignment FuncDef
%type <AbstractSyntax.types> TypeSpec
%type <AbstractSyntax.adtconstructor>
%%

Main:
    Program EOF { $1 }
;

Program:
    Expr       { $1 }
  | Assignment { $1 }
  | FuncDef    { $1 }
  | ADT        { $1 }

Value:
    CONSTINT                    { ConstantInteger $1 }
  | CONSTBOOL                   { ConstantBoolean $1 }
  | NAME                        { Variable $1 }
  | LPAR Value COMMA Value RPAR { Tuple($2, $4) }

Expr:
  | Exp NOTEQL Exp  { Prim("!=", $1, $3) }
  | Exp EQL    Exp  { Prim("==", $1, $3) }
  | Exp GT     Exp  { Prim(">",  $1, $3) }
  | Exp LT     Exp  { Prim("<",  $1, $3) }
  | Exp GE     Exp  { Prim(">=", $1, $3) }
  | Exp LE     Exp  { Prim("<=", $1, $3) }
  | Exp             { $1 }

Exp:
  | Value           { $1                 }
  | MINUS Exp       { Prim("-", ConstantInteger 0, $2)  }
  | Exp PLUS  Exp   { Prim("+", $1, $3)  }
  | Exp MINUS Exp   { Prim("-", $1, $3)  }
  | Exp TIMES Exp   { Prim("*", $1, $3)  }
  | Exp DIV   Exp   { Prim("/", $1, $3)  }
  | Exp MOD   Exp   { Prim("%", $1, $3)  }
  | LPAR Expr RPAR  { $2 }

Assignment:
    NAME ASSIGN Expr NEWLINE { Let($1, $3) }
  | ADT NEWLINE              { $1 }

ExprList:
    Expr NEWLINE          { [$1] }
  | NEWLINE ExprListInner { $2 }

ExprListInner:
    Expr NEWLINE END           { [$1] }
  | Expr NEWLINE ExprListInner { $1 :: $3 }

FuncDef:
  FUNCTION NAME NAME ASSIGN ExprList { Function($2, $3, $5 ) }

// ====== ADT grammar rules: =======
ADT:
  TYPE NAME ASSIGN ADTContructor { ADT($2, $4) }

ADTContructor:
    ADTSimpleConstructor   { $1 }
  | ADTCompoundConstructor { $1 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter                    { [adtconstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { adtconstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

ADTConstructorParameter:
  | /* empty */                      { [] }
  | TypeSpec ADTConstructorParameter { $1::$2 }

TypeSpec:
    INT     { Int }
  | FLOAT   { Float }
  | BOOLEAN { Boolean }
  | STRING  { String }
  | CHAR    { Char }
  | NAME    { Typevar $1 }
