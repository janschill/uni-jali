%{
  open AbstractSyntax;
%}

%token <bool> CONSTBOOL
%token <int> CONSTINT
%token <string> NAME
%token ASSIGN
%token BOOLEAN
%token CHAR
%token COMMA
%token DIV
%token ELSE
%token ELSEIF
%token END
%token EOF
%token EQL
%token FLOAT
%token FUNCTION
%token GE
%token GT
%token IF
%token INT
%token LARROW
%token LE
%token LPAR
%token LT
%token MATCH
%token MINUS
%token MOD
%token NEWLINE
%token NOT
%token NOTEQL
%token PIPE
%token PLUS
%token RARROW
%token RPAR
%token STRING
%token THEN
%token TIMES
%token TYPE
%token USCORE
%token WITH

/* lowest precedence  */
%left ELSE
%left PLUS MINUS
%left TIMES DIV MOD
/* highest precedence  */
%nonassoc NOT

%start Main
%type <AbstractSyntax.Expr> Main Value Expr Exp ADT FuncDef
%type <AbstractSyntax.Type> TypeSpec
%%

Main:
    Program EOF { $1 }
;

Program: DeclarationList  { Program( $1 ) }

DeclarationList:
  | Declaration { [$1] }
  | Declaration NEWLINE                  { [$1] }   // handles newlines at end of file
  | Declaration NEWLINE DeclarationList  { $1 :: $3 }
Declaration:
  | Expr                { $1 }
  | LetBinding          { $1 }
  | FuncDef             { $1 }
  | ADT                 { $1 }
  | NEWLINE Declaration { $2 }    // handles empty lines

// Stmt:
// | NAME ASSIGN Expr NEWLINE { Let($1, $3) }
// | BEGIN StmtList END { Seq(List.rev($2)) }    I want this one :'(

Expr: // Lower precedence
  | Exp NOTEQL Exp { Prim("!=", $1, $3) }
  | Exp EQL    Exp { Prim("==", $1, $3) }
  | Exp GT     Exp { Prim(">",  $1, $3) }
  | Exp LT     Exp { Prim("<",  $1, $3) }
  | Exp GE     Exp { Prim(">=", $1, $3) }
  | Exp LE     Exp { Prim("<=", $1, $3) }
  | Exp            { $1 }
Exp: // Higher precedence
  | Value { $1 }
  | LetBinding { $1 }
  | IfStatement { $1 }
  | FuncDef { $1 }
  | FuncCall { $1 }
  | MatchExpr { $1 }
  | MINUS Exp { Prim("-", Constant (IntegerValue 0), $2) }
  | Exp PLUS  Exp                   { Prim("+", $1, $3) }
  | Exp MINUS Exp                   { Prim("-", $1, $3) }
  | Exp TIMES Exp                   { Prim("*", $1, $3) }
  | Exp DIV   Exp                   { Prim("/", $1, $3) }
  | Exp MOD   Exp                   { Prim("%", $1, $3) }
  | LPAR Expr RPAR                  { $2 }

Value:
    PrimitiveValue { Constant($1) }
  | NAME           { Variable $1 }
PrimitiveValue:
    CONSTINT                    { IntegerValue $1 }
  | CONSTBOOL                   { BooleanValue $1 }
  | NAME PrimitiveValue         { ADTValue($1, $2) }
  | LPAR PrimitiveValue COMMA PrimitiveValue RPAR { Tuple($2, $4) }

IfStatement: IF AtExpr THEN AtExp ELSE AtExp { If($2, $4, $6) }
AtExpr:
  | Expr NEWLINE { $1 }
  | Expr         { $1 }
AtExp:
  | Exp NEWLINE { $1 }
  | Exp         { $1 }

FuncCall: NAME Args { Apply($1, $2) }
Args:
  | /* empty */ { [] }
  | Arg Args    { $1::$2 }
Arg:
  | Value { $1 }
  | LPAR Exp RPAR { $2 }

MatchExpr: MATCH Expr WITH NEWLINE PatternBody { Pattern($2, $5) }
PatternParameter:
    Expr { [$1] }
  | Expr COMMA PatternParameter { $1::$3 }
PatternBody:
    PIPE Value RARROW Expr                      { [($2, $4)] }
  | PIPE Value RARROW Expr NEWLINE PatternBody  { ($2, $4)::$5 }
  // | PIPE USCORE RARROW FuncExprList NEWLINE PatternBody { ($2, $4)::$6 }

LetBinding: 
  | NAME ASSIGN Expr NEWLINE Expr { Let($1, $3, $5) }
  | NAME ASSIGN Expr NEWLINE Declaration { Let($1, $3, $5) }

FuncDef:
  | FUNCTION NAME Params ASSIGN Expr NEWLINE Expr { Function($2, $3, $5, $7) }
  | FUNCTION NAME Params ASSIGN NEWLINE Expr NEWLINE Expr { Function($2, $3, $6, $8) }
  // | FUNCTION NAME Params ASSIGN NEWLINE Expr NEWLINE Expr NEWLINE { Function($2, $3, $6, $8) }
Params:
  | /* empty */        { [] }
  | NAME Params { $1::$2 }

// THIS IS OUR PROGRAM?? 
// FuncDef:
//   | FUNCTION NAME Params ASSIGN Expr { Function($2, $3, $5 ) }
//   | FUNCTION NAME Params ASSIGN NEWLINE FuncExprList END { Function($2, $3, $6 ) }
// Params:
//   | /* empty */        { [] }
//   | NAME Params { $1::$2 }
// FuncExprList:
//   | Expr NEWLINE { [$1] }
//   | LetBinding NEWLINE FuncExprList   { $1 :: $3 }
//   | FuncDef FuncExprList              { $1 :: $2 }


// ====== ADT grammar rules: =======
ADT:
  TYPE NAME ASSIGN ADTContructor { ADT($2, $4) }

ADTContructor:
    ADTSimpleConstructor   { $1 }
  | ADTCompoundConstructor { $1 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter                    { [ADTConstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { ADTConstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

ADTConstructorParameter:
  | /* empty */ { [] }
  | TypeSpec ADTConstructorParameter { $1::$2 }

TypeSpec:
    INT     { Int }
  | FLOAT   { Float }
  | BOOLEAN { Boolean }
  | STRING  { String }
  | CHAR    { Char }
  | NAME    { Typevar $1 }
