%{
  open AbstractSyntax;
%}

// Tokens:
%token <int> CONSTINT
%token <bool> CONSTBOOL
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD
%token ASSIGN
%token EOF
%token NOTEQ GT LT GE LE

// Not implemented:
%token IF ELSEIF ELSE EQL NOT
%token LPAR RPAR COMMA
%token NEWLINE FUNCTION END

%left ELSE              /* lowest precedence  */
%left PLUS MINUS
%left TIMES DIV MOD

%nonassoc NOT           /* highest precedence  */

%start Main
%type <AbstractSyntax.expr> Main Program Value Expr Assignment FuncDef FuncBody SingleLineStatemet CompoundStatement Statement

%%

Main:
    Program EOF { $1 }
;

Program:
    Expr { $1 }
  | Assignment { $1 }
  | FuncDef { $1 }

Value:
    CONSTINT { ConstantInteger $1 }
  | CONSTBOOL { ConstantBoolean $1 }
  | NAME { Variable $1 }
  | LPAR Value COMMA Value RPAR { Tuple($2, $4) }

Expr:
    Value           { $1                 }
  | MINUS Expr      { Prim("-", ConstantInteger 0, $2)  }
  | Expr PLUS Expr  { Prim("+", $1, $3)  }
  | Expr MINUS Expr { Prim("-", $1, $3)  }
  | Expr TIMES Expr { Prim("*", $1, $3)  }
  | Expr DIV   Expr { Prim("/", $1, $3)  }
  | Expr MOD   Expr { Prim("%", $1, $3)  }
  | Expr NOTEQ Expr { Prim("!=", $1, $3) }
  | Expr GT    Expr { Prim(">",  $1, $3) }
  | Expr LT    Expr { Prim("<",  $1, $3) }
  | Expr GE    Expr { Prim(">=", $1, $3) }
  | Expr LE    Expr { Prim("<=", $1, $3) }
;

Assignment:
  NAME ASSIGN Expr NEWLINE { Let($1, $3) }

FuncDef:
  FUNCTION NAME NAME ASSIGN ExprList { Function($2, $3, ($5 |> List)) }

ExprList:
    Expr NEWLINE { [$1] }
  | NEWLINE ExprList Expr END { $3 :: $2 }

FuncBody:
    SingleLineStatemet NEWLINE { $1 }
  | CompoundStatement { $1 }

SingleLineStatemet: Expr { $1 }

CompoundStatement: 
    NEWLINE Statement NEWLINE END { $2 }

Statement:
    Expr { $1 }
  | Assignment { $1 }
  | Expr NEWLINE Statement { $1, $3 }
  | Assignment NEWLINE Statement { $1, $3 }


// | LPAR Expr RPAR                           { $2          }
