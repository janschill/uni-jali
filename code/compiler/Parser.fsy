%{
  open AbstractSyntax;
%}

%token <bool> CONSTBOOL
%token <int> CONSTINT
%token <string> NAME
%token ASSIGN
%token BOOLEAN
%token CHAR
%token COMMA
%token DIV
%token ELSE
%token ELSEIF
%token END
%token EOF
%token EQL
%token FLOAT
%token FUNCTION
%token GE
%token GT
%token IF
%token INT
%token LARROW
%token LE
%token LPAR
%token LT
%token MATCH
%token MINUS
%token MOD
%token NEWLINE
%token NOT
%token NOTEQL
%token PIPE
%token PLUS
%token RARROW
%token RPAR
%token STRING
%token THEN
%token TIMES
%token TYPE
%token USCORE
%token WITH

/* lowest precedence  */
%left ELSE
%left PLUS MINUS
%left TIMES DIV MOD
/* highest precedence  */
%nonassoc NOT

%start Main
%type <AbstractSyntax.Expr> Main Expression ADT FunctionBinding
%type <AbstractSyntax.Type> TypeSpec
%%

/*
# Grammar

AtomicExpression:
  Constant literal
  Local variable, parameter
  Local binding
  Function binding
  Parenthesized expression

AppExpression:
  One-argument function call
  Multi-argument function call

Expression:
  Atomic expression
  Function call
  Conditional expression
  Logical negation
  Arithemtic, comparison
*/

Main:
    Expression EOF { $1 }
;

Expression:
  | AtomicExpression { $1 }
  | AppExpression { $1 }
  | ConditionalExpression { $1 }
  | LogicalNegation { $1 }
  | ArtihemticExpression { $1 }
  | ComparisonExpression { $1 }

AtomicExpression:
  | ConstantLiteral { $1 } // constant literal and local variable, parameter
  | LocalBinding { $1 }
  | FunctionBinding { $1 }
  | ParenthesizedExpression { $1 }

ConstantLiteral:
  | CONSTINT { Constant (IntegerValue $1) }
  | CONSTBOOL { Constant (BooleanValue $1) }
  | NAME { Variable $1 }
  | ADTValue { $1 }
  | LPAR /* what here? */ RPAR { Tuple($2, $4) }

LocalBinding:
  | NAME ASSIGN Expression NEWLINE Expression { Let($1, $3, $5) }

FunctionBinding:
  | FUNCTION NAME Params ASSIGN Expression NEWLINE Expression { Function($2, $3, $5, $7) }
  | FUNCTION NAME Params ASSIGN NEWLINE Expression NEWLINE Expression { Function($2, $3, $6, $8) }
  // | FUNCTION NAME Params ASSIGN NEWLINE Expression NEWLINE Expression NEWLINE { Function($2, $3, $6, $8) }
Params:
  | /* empty */ { [] }
  | NAME Params { $1::$2 }

ParenthesizedExpression:
  | LPAR Expression RPAR { $2 }

AppExpression:
  | FunctionCall { $1 }

FunctionCall: NAME Args { Apply($1, $2) }
Args:
  | /* empty */ { [] }
  | Arg Args { $1::$2 }
Arg:
  | ConstantLiteral { $1 }
  | LPAR Expression RPAR { $2 }

ConditionalExpression:
  | IfStatement { $1 }
  | MatchExpr { $1 }

IfStatement:
  | IF Expression THEN Expression ELSE Expression { If($2, $4, $6) }

MatchExpr: MATCH Expression WITH NEWLINE PatternBody { Pattern($2, $5) }
PatternBody:
    PIPE ConstantLiteral RARROW Expression { [($2, $4)] }
  | PIPE ConstantLiteral RARROW Expression NEWLINE PatternBody { ($2, $4)::$6 }
  // | PIPE USCORE RARROW FuncExprList NEWLINE PatternBody { ($2, $4)::$6 }

LogicalNegation:
  | MINUS Expression { Prim("-", Constant (IntegerValue 0), $2) }
ArtihemticExpression:
  | Expression PLUS Expression { Prim("+", $1, $3) }
  | Expression MINUS Expression { Prim("-", $1, $3) }
  | Expression TIMES Expression { Prim("*", $1, $3) }
  | Expression DIV Expression { Prim("/", $1, $3) }
  | Expression MOD Expression { Prim("%", $1, $3) }
ComparisonExpression:
  | Expression NOTEQL Expression { Prim("!=", $1, $3) }
  | Expression EQL Expression { Prim("==", $1, $3) }
  | Expression GT Expression { Prim(">",  $1, $3) }
  | Expression LT Expression { Prim("<",  $1, $3) }
  | Expression GE Expression { Prim(">=", $1, $3) }
  | Expression LE Expression { Prim("<=", $1, $3) }

// ====================


PrimitiveValueList:
  | /* empty */ { [] }
  | ConstantLiteral PrimitiveValueList { $1::$2 }
ADTValue:
  | NAME PrimitiveValueList { ADTValue($1, $2) }

ADT:
  TYPE NAME ASSIGN ADTContructor { ADT($2, $4) }

ADTContructor:
    ADTSimpleConstructor { $1 }
  | ADTCompoundConstructor { $1 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter { [ADTConstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { ADTConstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

ADTConstructorParameter:
  | /* empty */ { [] }
  | TypeSpec ADTConstructorParameter { $1::$2 }

TypeSpec:
    INT { Int }
  | FLOAT { Float }
  | BOOLEAN { Boolean }
  | STRING { String }
  | CHAR { Char }
  | NAME { Typevar $1 }
