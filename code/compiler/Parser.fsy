%{
  open AbstractSyntax;
%}

%token <bool> CONSTBOOL
%token <int> CONSTINT
%token <string> NAME
%token ASSIGN
%token BOOLEAN
%token CHAR
%token COMMA
%token DIV
%token ELSE
%token ELSEIF
%token END
%token EOF
%token EQL
%token FLOAT
%token FUNCTION
%token GE
%token GT
%token IF
%token INT
%token LARROW
%token LE
%token LPAR
%token LT
%token MATCH
%token MINUS
%token MOD
%token NEWLINE
%token NOT
%token NOTEQL
%token PIPE
%token PLUS
%token RARROW
%token RPAR
%token STRING
%token THEN
%token TIMES
%token TYPE
%token USCORE
%token WITH

/* lowest precedence  */
%left ELSE
%left PLUS MINUS
%left TIMES DIV MOD
/* highest precedence  */
%nonassoc NOT

%start Main
%type <AbstractSyntax.Expr> Main Value Expr Exp ADT Assignment FuncDef
%type <AbstractSyntax.Type> TypeSpec
%%

Main:
    Program EOF { $1 }
;

Program: DeclarationList  { Program( $1 ) }

Declaration:
  | Assignment          { $1 }
  | FuncDef             { $1 }
  | ADT                 { $1 }
  | NEWLINE Declaration { $2 }    // handles empty lines

// Stmt:
// | NAME ASSIGN Expr NEWLINE { Let($1, $3) }
// | BEGIN StmtList END { Seq(List.rev($2)) }    I want this one :'(

DeclarationList:
  | Declaration                          { [$1] }
  | Declaration NEWLINE                  { [$1] }   // handles newlines at end of file
  | Declaration NEWLINE DeclarationList  { $1 :: $3 }

PrimitiveValue:
    CONSTINT                    { IntegerValue $1 }
  | CONSTBOOL                   { BooleanValue $1 }
  | NAME PrimitiveValue         { ADTValue($1, $2) }
  | LPAR PrimitiveValue COMMA PrimitiveValue RPAR { Tuple($2, $4) }

Value:
    PrimitiveValue { Constant($1) }
  | NAME           { Variable $1 }

// Higher precedence
Exp:
  | Value                           { $1 }
  | NAME Args                       { Apply($1, $2) }
  | IF AtExpr THEN AtExp ELSE AtExp { If($2, $4, $6) }
  | MATCH Expr WITH NEWLINE PatternBody { Pattern($2, $5) }
  | MINUS Exp                       { Prim("-", Constant (IntegerValue 0), $2) }
  | NAME ASSIGN Expr NEWLINE Expr   { Let($1, $3, $5) }
  | NAME ASSIGN Expr NEWLINE Declaration { Let($1, $3, $5) }
  | Exp PLUS  Exp                   { Prim("+", $1, $3) }
  | Exp MINUS Exp                   { Prim("-", $1, $3) }
  | Exp TIMES Exp                   { Prim("*", $1, $3) }
  | Exp DIV   Exp                   { Prim("/", $1, $3) }
  | Exp MOD   Exp                   { Prim("%", $1, $3) }
  | LPAR Expr RPAR                  { $2 }

PatternBody:
    PIPE Value RARROW Expr                      { [($2, $4)] }
  | PIPE Value RARROW Expr NEWLINE PatternBody  { ($2, $4)::$5 }
  // | PIPE USCORE RARROW FuncExprList NEWLINE PatternBody { ($2, $4)::$6 }

// Lower precedence
Expr:
  | Exp NOTEQL Exp { Prim("!=", $1, $3) }
  | Exp EQL    Exp { Prim("==", $1, $3) }
  | Exp GT     Exp { Prim(">",  $1, $3) }
  | Exp LT     Exp { Prim("<",  $1, $3) }
  | Exp GE     Exp { Prim(">=", $1, $3) }
  | Exp LE     Exp { Prim("<=", $1, $3) }
  | Exp            { $1 }

AtExpr:
  | Expr NEWLINE { $1 }
  | Expr         { $1 }

AtExp:
  | Exp NEWLINE { $1 }
  | Exp         { $1 }

Arg:
  | Value { $1 }
  | LPAR Exp RPAR { $2 }
Args:
  | /* empty */ { [] }
  | Arg Args    { $1::$2 }

Assignment: // statement

FuncExprList:
  | Expr NEWLINE                      { [$1] }
  | Assignment NEWLINE FuncExprList   { $1 :: $3 }
  | FuncDef FuncExprList              { $1 :: $2 }

FuncDef:
  | FUNCTION NAME FuncParameter ASSIGN Expr                     { Function($2, $3, [$5] ) }
  | FUNCTION NAME FuncParameter ASSIGN NEWLINE FuncExprList END { Function($2, $3, $6 ) }

FuncParameter:
  | /* empty */        { [] }
  | NAME FuncParameter { $1::$2 }

// ====== ADT grammar rules: =======
ADT:
  TYPE NAME ASSIGN ADTContructor { ADT($2, $4) }

ADTContructor:
    ADTSimpleConstructor   { $1 }
  | ADTCompoundConstructor { $1 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter                    { [ADTConstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { ADTConstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

ADTConstructorParameter:
  | /* empty */                      { [] }
  | TypeSpec ADTConstructorParameter { $1::$2 }

TypeSpec:
    INT     { Int }
  | FLOAT   { Float }
  | BOOLEAN { Boolean }
  | STRING  { String }
  | CHAR    { Char }
  | NAME    { Typevar $1 }
