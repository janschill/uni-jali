%{
  open AbstractSyntax;
%}

// Tokens:
%token <int> CONSTINT
%token <bool> CONSTBOOL
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD
%token ASSIGN
%token EOF
%token NOTEQ GT LT GE LE

// Not implemented:
%token IF ELSEIF ELSE EQL NOT
%token LPAR RPAR
%token NEWLINE INDENT DEDENT FUNCTION

%left ELSE              /* lowest precedence  */
%left PLUS MINUS
%left TIMES DIV MOD

%nonassoc NOT           /* highest precedence  */

%start Main
%type <AbstractSyntax.expr> Main Expr AtExpr

%%

Main:
    Expr EOF { $1 }
;

Expr:
    AtExpr          { $1                 }
  | MINUS Expr      { Prim("-", CstI 0, $2)  }
  | Expr PLUS Expr  { Prim("+", $1, $3)  }
  | Expr MINUS Expr { Prim("-", $1, $3)  }
  | Expr TIMES Expr { Prim("*", $1, $3)  }
  | Expr DIV   Expr { Prim("/", $1, $3)  }
  | Expr MOD   Expr { Prim("%", $1, $3)  }

  | Expr NOTEQ Expr { Prim("!=", $1, $3) }
  | Expr GT    Expr { Prim(">",  $1, $3) }
  | Expr LT    Expr { Prim("<",  $1, $3) }
  | Expr GE    Expr { Prim(">=", $1, $3) }
  | Expr LE    Expr { Prim("<=", $1, $3) }
;

AtExpr:
    Const                                       { $1          }
  | NAME ASSIGN Expr NEWLINE                    { Let($1, $3) }
  | FUNCTION NAME NAME ASSIGN NEWLINE INDENT Expr DEDENT { Function($2, $3, $7) }
  | LPAR Expr RPAR                           { $2          }

Const:
    CONSTINT        { ConstantInteger $1 }
  | CONSTBOOL       { ConstantBoolean $1 }
