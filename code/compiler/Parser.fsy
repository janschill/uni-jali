%{
  open AbstractSyntax;
%}

// Tokens:
%token <int> CONSTINT
%token <bool> CONSTBOOL
%token <string> NAME
%token PLUS MINUS TIMES DIV MOD
%token ASSIGN
%token EOF
%token NOTEQ GT LT GE LE

// Not implemented:
%token IF ELSEIF ELSE EQL NOT
%token LPAR RPAR COMMA PIPE TYPE
%token NEWLINE FUNCTION END
%token INT FLOAT BOOLEAN STRING CHAR

%left ELSE              /* lowest precedence  */
%left PLUS MINUS
%left TIMES DIV MOD

%nonassoc NOT           /* highest precedence  */

%start Main
%type <AbstractSyntax.expr> Main Program Value Expr ADT Assignment FuncDef // Statement SimpleStatement CompoundStatement FuncBody
%type <AbstractSyntax.types> Type
%type <AbstractSyntax.adtconstructor>
%%

Main:
    Program EOF { $1 }
;

Program:
    Expr { $1 }
  | Assignment { $1 }
  | FuncDef { $1 }
  | ADT { $1 }

Value:
    CONSTINT { ConstantInteger $1 }
  | CONSTBOOL { ConstantBoolean $1 }
  | NAME { Variable $1 }
  | LPAR Value COMMA Value RPAR { Tuple($2, $4) }

Expr:
    Value           { $1                 }
  | MINUS Expr      { Prim("-", ConstantInteger 0, $2)  }
  | Expr PLUS Expr  { Prim("+", $1, $3)  }
  | Expr MINUS Expr { Prim("-", $1, $3)  }
  | Expr TIMES Expr { Prim("*", $1, $3)  }
  | Expr DIV   Expr { Prim("/", $1, $3)  }
  | Expr MOD   Expr { Prim("%", $1, $3)  }
  | Expr NOTEQ Expr { Prim("!=", $1, $3) }
  | Expr GT    Expr { Prim(">",  $1, $3) }
  | Expr LT    Expr { Prim("<",  $1, $3) }
  | Expr GE    Expr { Prim(">=", $1, $3) }
  | Expr LE    Expr { Prim("<=", $1, $3) }
;

// ====== ADT grammar rules: =======
Type:
    INT     { Int }
  | FLOAT   { Float }
  | BOOLEAN { Boolean }
  | STRING  { String }
  | CHAR    { Char }

ADTConstructorParameter:
    Type { [$1] }
  | Type ADTConstructorParameter { $1::$2 }

ADTSimpleConstructor:
    NAME ADTConstructorParameter { [adtconstructor($1, $2)] }
  | NAME ADTConstructorParameter PIPE ADTContructor { adtconstructor($1, $2)::$4 }

ADTCompoundConstructor:
    NEWLINE ADTSimpleConstructor { $2 }

ADTContructor:
    ADTSimpleConstructor { $1 }
  | ADTCompoundConstructor { $1 }

ADT:
  Type NAME ASSIGN ADTContructor { ADT($2, $4) }
// =================================

Assignment:
    NAME ASSIGN Expr NEWLINE { Let($1, $3) }
  | ADT NEWLINE { $1 }

// ==== Function grammar rules: ====
// Statement:
//     Expr { $1 }
//   | Assignment { $1 }
//   | Expr NEWLINE Statement { $1, $3 }
//   | Assignment NEWLINE Statement { $1, $3 }

// SimpleStatement: Expr { $1 }

// CompoundStatement: NEWLINE Statement NEWLINE END { $2 }

// FuncBody:
//     SimpleStatement NEWLINE { $1 }
//   | CompoundStatement { $1 }

ExprList:
    { [] }
  | Expr NEWLINE { [$1] }
  | NEWLINE ExprList Expr END { $3 :: $2 }

FuncDef:
  FUNCTION NAME NAME ASSIGN ExprList { Function($2, $3, $5 ) }

// =================================