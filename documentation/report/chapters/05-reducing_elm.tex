% Chapter 5
% Reducing the Elm model
%   Apply reducer, what do we get
%   How far away is the plain JavaScript button implementation to ours from JaLi
%   Yeah
%     javascript2 = reduce ( patchToJs (diff (view model) (view (update Decrement model))))
  
% The patchToJS function generates JavaScript that makes changes during runtime to the model.
% __________________________________________________________________________________
This chapter focuses on the reduction of the model-view-update architecture and its result when using the JaLi compiler with partial evaluation implemented.
The previously shown example of two buttons with a counter text field shall be continued here.

To revisit the desired outcome of having two small JavaScript snippets that sit on the buttons that apply the change directly onto the \gls{dom} node, it needs to be figured out now, how to achieve this by reducing the model-view-update architecture.

When an update on the \gls{dom} is happening \textit{diffing} (see chapter \ref{Model-view-update-architecture-in-JaLi}) needs to take place.
This diffing however is expensive, because it needs to iterate through both views and compare their nodes, until it has calculated the complete \textit{Differ} path, knowing where all changes are that need patching. For this reason the diffing should only happen when absolutely necessary or even better happen during compile time and reduced to optimized functions, that can be directly used.

Continuing with the button example from the previous chapters, it is intuitive to see that the two increment and decrement buttons will always only change the model by either incrementing or decrementing its value by one. It is also only being rendered by one single \gls{dom} node.

\begin{figure}[H]
    \centering
    \begin{verbatim}
    func view model =
      Tag ('div') ([]) ([
        Tag ('button') ([
            (Click, (onClick (Increment)))]) ([Text ('Increment')
        ]),
        Tag ('p') ([]) ([
          Text (model)
        ]),
        Tag ('button') (
            [(Click, (onClick (Decrement)))]) ([Text ('Decrement')
        ]),
      ])
    end
    \end{verbatim}
    \caption{ADT of button example}
    \label{fig:button-view-function}
\end{figure}

The only problem when wanting to reduce, is that during compile time when the reducer is applied the model cannot be known. Using an initial value 0 on the model, would cause the problem that the reducer would generate two functions that either add or subtract 1 to 0. Therefor two functions need to be generated where the model is treated as dynamic:

\begin{verbatim}
updateIncrement: update Increment dynamic:model
updateDecrement: update Decrement dynamic:model
\end{verbatim}

This also means, that in the end our run-time needs to hold some state for the model, which can then be passed to the partially evaluated \texttt{updateIncrement} and \texttt{updateDecrement} functions.
The state would be generated by a JavaScript compiler, that would compile the whole JaLi program into JavaScript, this JavaScript compiler is not implemented. 
The update on the model is not enough though, since the \gls{dom} needs to be patched as well. The \textit{onClick} handler attached to the button essentially calls a function: \textit{updateAndPatch}.

\begin{figure}[H]
    \centering
    \begin{verbatim}
      func updateAndPatch action = 
        oldModel = readGlobal ("model");
        newModel = update (action) (oldModel);
        eval (patchToJs (diff (view newModel) (view (oldModel))))
        setGlobal ("model") (newModel)
      end
    \end{verbatim}
    \caption{Function called by onClick handler}
    \label{fig:updateAndPatch}
\end{figure}

Figure \ref{fig:updateAndPatch} shows four operations performed when called.
\begin{enumerate}
    \item It reads a global variable that is called \textit{model} and assigns it to \textit{oldModel}
    \item Generates a new model based on the \textit{Action} passed and the \textit{oldModel}
    \item Evaluates the JavaScript string returned from the patch on the old view and new view
    \item Set the global variable to the value of \textit{newModel}
\end{enumerate}

The two parts that get reduced here and are crucial for performance gain is the \textit{update} and the \textit{diff} functions.
These two function calls would be reduced as there are two different actions:

\begin{figure}[H]
    \centering
    \begin{verbatim}
        diff (view dynamic:model) (view (update Increment dynamic:model))
        diff (view dynamic:model) (view (update Decrement dynamic:model))
    \end{verbatim}
    \caption{Increment and Decrement diff calls}
    \label{fig:diff-inc-dec}
\end{figure}

The reduction of these two calls will yield a a partially evaluated function, that will always return the same \textit{Differ} path, and only the actual \textit{Change} constructor from the \textit{Differ} data type, will be different.
This means that for all actions that update the model and thus change the view, will be calculated and reduced during compiling to the point that only the value of the to be inserted node is missing, which means no \gls{dom} compare/diffing needs to be done during run-time.

All other parts in \ref{fig:updateAndPatch} will be treated by the reducer as dynamic -- the setting of the global model -- and hence not reduced further.



\jan{show reduced diff function}
\jan{show the parts in fig 3}

The JavaScript compiler would then generate JavaScript code from the whole JaLi program and generate a run-time that would have access to a \textit{model} that could be passed to the partially applied JavaScript function generated by the compiler based on the reduction of the whole program

\jan{TODO: here show JavaScript snippets that make the change}

\jan{TODO: 
- JavaScript snippets
- Reduction of Differ
- Reduction of patchToJs
}

\begin{verbatim}
document.body.children[0].children[1].children[0].innerHTML = 1;
\end{verbatim}

\jan{backlog: write JaLi function eval that calls JavaScript eval}

% \begin{figure}
%     \centering
%     \begin{verbatim}
%     func incrementDynamicPatchToJs dynamic_model = 
%         view1 = view (dynamic_model);
%         view2 = view (update Increment dynamic_model);
%         patchToJs view1 (diff view1 view2)
%     end
%     \end{verbatim}
%     \caption{Patch function with dynamic model}
%     \label{fig:dynamicPatchToJs}
% \end{figure}

% The \textit{dynamicPatchToJs} function from Fig. \ref{fig:dynamicPatchToJs}. shows how it generates two views on a dynamic model, where one view is being updated by an \textit{Increment}.

% The partially evaluated \textit{diff} function is not yet enough though, because it still needs to be used to patch the view.
% As previously stated that the patching cannot be done during compiling, due to the lack of information regarding the dynamic variable model, the \textit{patch} function needs to generate JavaScript that can be executed during run-time, where the model is known in form of a state variable.